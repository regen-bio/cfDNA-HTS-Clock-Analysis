#!/usr/bin/env snakemake
# this is 

# external programs and resources
methyl_dackel = "MethylDackel"
bedtools = "bedtools"
liftover = "liftOver"
ref_hg38 = "hg38_merged.fa"
cpg_hg38 = "hg38_cpg_sites.bed"
probe_ref = "msa_hm450_epic_epic2_hg38.bed"
chain_hg38 = "hg19ToHg38.over.chain.gz"

# load sample bed files to process
with open("list", "r") as fp:
	samples = fp.read().splitlines()

# 1st: liftover from hg19 to hg38
# 2nd: intersect with hg38 cpg sites
# 3rd: merge context
# 4th: intersect with probe cpg sites
# 5th: extract beta and depth
# 6th: merge into beta and depth matrix


rule all:
	input:
		"beta_matrix.tsv",
		"depth_matrix.tsv",


rule probe_ref_copy:
	input:
		probe_ref,
	output:
		"probe_hg38.ref.bed",
	shell:
		"""
		rsync -tlv {input} {output}
		"""

rule probe_ref_merge:
	input:
		"probe_hg38.ref.bed",
	params:
		bedtools = bedtools,
	output:
		"probe_hg38.ref.merged.bed",
	shell:
		"""
		{params.bedtools} sort -i {input} |
		{params.bedtools} merge -i - \
		> {output}
		"""

for s in samples:
# liftover from hg19 to hg38
	rule:
		name: f"{s}_liftover"
		input:
			f"{s}.bed.gz",
		params:
			bedtools = bedtools,
			liftover = liftover,
			chain = chain_hg38,
			tmp_sorted = f"{s}.sorted.bed",
			tmp_liftover = f"{s}.hg38.tmp.bed",
		output:
			mapped = f"{s}.hg38.bed",
			unmapped = f"{s}.hg38.unmapped.bed",
		shell:
			"""
			{params.bedtools} sort -i {input} > {params.tmp_sorted}
			{params.liftover} {params.tmp_sorted} {params.chain} {params.tmp_liftover} {output.unmapped}
			awk '!seen[$1,$2,$3]++' {params.tmp_liftover} > {output.mapped}
			rm -f {params.tmp_sorted} {params.tmp_liftover}
			"""

# intersect with hg38 cpg sites
	rule:
		name: f"{s}_cpg_intersect"
		input:
			f"{s}.hg38.bed",
		params:
			bedtools = bedtools,
			cpg_bed = cpg_hg38,
		output:
			f"{s}.hg38.cpg.bed",
		shell:
			"""
			{params.bedtools} intersect \
				-a {input} \
				-b {params.cpg_bed} -wa |
			grep -v 'chrM' |
			awk 'BEGIN{{OFS="\t"}} {{d = int($5 + 0.5); if (d != 0) b = int($4 / d * 100); else b = 0; print ($1, $2, $3, int($6 * 100), $4, (d - $4 > 0 ? d - $4 : 0)) }}' \
			> {output}
			"""

# merge context
	rule:
		name: f"{s}_merge_context"
		input:
			f"{s}.hg38.cpg.bed",
		params:
			methyl_dackel = methyl_dackel,
			ref_genome = ref_hg38,
		output:
			f"{s}.hg38.cpg.merged.bed",
		shell:
			"""
			{params.methyl_dackel} mergeContext \
				{params.ref_genome} \
				{input} |
			awk 'BEGIN{{OFS="\t"}} {{if (($3 - $2) == 2) print}}' \
			> {output}
			"""

# intersect with probe cpg sites
	rule:
		name: f"{s}_probe_intersect"
		input:
			bed = f"{s}.hg38.cpg.merged.bed",
			probe_ref = "cpg_hg38.merged.bed",
		params:
			bedtools = bedtools,
		output:
			f"{s}.hg38.cpg.merged.probe.bed",
		shell:
			"""
			{params.bedtools} intersect \
				-a {input.bed} \
				-b {input.probe_ref} \
				-wa |
			{params.bedtools} sort -i - |
			awk '!seen[$1,$2,$3]++' \
			> {output}
			"""

# extract beta and depth
	rule:
		name: f"{s}_extract"
		input:
			f"{s}.hg38.cpg.merged.probe.bed",
		output:
			beta = f"{s}.beta.bed",
			depth = f"{s}.depth.bed",
		run:
			ifp = open(input[0], "r")
			ofp_beta = open(output.beta, "w")
			ofp_depth = open(output.depth, "w")

			for line in ifp:
				if line.startswith("track"):
					continue
				fields = line.strip().split("\t")
				m = int(fields[4])
				u = int(fields[5])
				if (depth := m + u):
					beta = m / depth
				else:
					beta = 0
				print(("\t").join(fields[0:3] + ["%.4f" % beta]), file=ofp_beta)
				print(("\t").join(fields[0:3] + [str(depth)]), file=ofp_depth)

			ifp.close()
			ofp_beta.close()
			ofp_depth.close()


output_mats = ["beta", "depth"]
for mat in output_mats:
# merge into single bed
	rule:
		name: f"{mat}_matrix_bed_gen"
		input:
			expand(f"{{sample}}.{mat}.bed", sample=samples),
		params:
			bedtools = bedtools,
			names = samples,
		output:
			f"{mat}_matrix.bed",
		shell:
			"""
			{params.bedtools} unionbedg \
				-i {input} \
				-header \
				-names {params.names} \
				> {output}
			"""

# merge with probe ref
	rule:
		name: f"{mat}_merge_probe"
		input:
			matrix = f"{mat}_matrix.bed",
			probe_ref = "probe_hg38.ref.bed",
		params:
			bedtools = bedtools,
		output:
			matrix_merge_probe = f"{mat}_matrix.probe_merge.bed",
		shell:
			"""
			{params.bedtools} intersect \
				-header \
				-a {input.matrix} \
				-b {input.probe_ref} \
				-wa -wb \
				> {output}
			"""

# rearrange columns and finalize matrix
	rule:
		name: f"{mat}_matrix"
		input:
			f"{mat}_matrix.probe_merge.bed",
		output:
			f"{mat}_matrix.tsv",
		run:
			ifp = open(input[0], "r")
			ofp = open(output[0], "w")

			n_acols = None

			for line in ifp:
				fields = line.strip().split("\t")
				if n_acols is None:
					n_acols = len(fields)
					fields = ["ID_REF"] + fields[3: n_acols]
				else:
					fields = [fields[-1]] + fields[3: n_acols]
				print(("\t").join(fields), file=ofp)

